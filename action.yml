name: Install Cygwin Action
description: GitHub Action to install Cygwin

inputs:
  platform:
    description: Platform [x86, x86_64]
    required: false
    default: x86_64
  packages:
    description: Packages to install
    required: false
  install-dir:
    # by default, install to C:\cygwin rather than the platform dependent
    # default to make everything simpler
    description: Installation directory
    required: false
    default: C:\cygwin
  check-sig:
    description: Should the setup.ini file signature be checked?
    required: false
    default: true
  site:
    description: Download site URL
    required: false
  add-to-path:
    description: Should Cygwin's bin directory be added to the system PATH?
    required: false
    default: true
  cache:
    description: Cache package downloads for speed
    required: false
    default: disabled
  cache-ref:
    description: Version of the cache action to use
    required: false
    default: v3

runs:
  using: "composite"
  steps:
    - shell: pwsh
      run: |
        if (("${{ inputs.cache }}" -ne "disabled") -and
            ("${{ inputs.cache-ref }}" -ne "v3.2.0") -and
            ("$(bash.exe --version)".contains("cygwin"))) {
          Write-Output "::warning title=Cache options issue::Cygwin binaries are in the path, and caching is running with a not-known-as-working cache action.  See cygwin-install-action README for details."
        } else if (("${{ inputs.cache-ref }}" -ne "v3") -and
                   ("${{ inputs.cache-ref }}" -ne "v3.2.0")) {
          Write-Output "::error title=Cache options issue::cache-ref must be 'v3' or 'v3.2.0'"
          exit 1
        }

    # The cache naming scheme means every run of this action should have a
    # different name.  That means there will always be a "cache miss", because
    # the name will never match a previous run.  That's good: we can still get
    # a partial cache hit, and we need a unique name because we can never tell
    # when the cache might need updating.
    #
    # The naming scheme also means that, if there are multiple caches
    # available, the most "local" one will be chosen, e.g. a cache from a
    # different job in this run will be chosen in preference to a cache from a
    # different run.
    - uses: actions/cache/restore@v3
      if: (inputs.cache == 'enabled' || inputs.cache == 'restoreonly') && inputs.cache-ref == 'v3'
      id: cache-restore3
      with:
        key: cygwin-install-action-packages-${{ github.run_id }}-${{ github.run_attempt }}-${{ github.job }}-${{ strategy.job-index }}-${{ github.action }}
        path: C:\cygwin-packages
        restore-keys: |
          cygwin-install-action-packages-${{ github.run_id }}-${{ github.run_attempt }}-${{ github.job }}-${{ strategy.job-index }}-
          cygwin-install-action-packages-${{ github.run_id }}-${{ github.run_attempt }}-${{ github.job }}-
          cygwin-install-action-packages-${{ github.run_id }}-${{ github.run_attempt }}-
          cygwin-install-action-packages-${{ github.run_id }}-
          cygwin-install-action-packages-

    # No way, as best I can tell, to parameterise the ref to use, so just
    # hard-code the options.
    - uses: actions/cache/restore@v3.2.0
      if: (inputs.cache == 'enabled' || inputs.cache == 'restoreonly') && inputs.cache-ref == 'v3.2.0'
      id: cache-restore320
      with:
        key: cygwin-install-action-packages-${{ github.run_id }}-${{ github.run_attempt }}-${{ github.job }}-${{ strategy.job-index }}-${{ github.action }}
        path: C:\cygwin-packages
        restore-keys: |
          cygwin-install-action-packages-${{ github.run_id }}-${{ github.run_attempt }}-${{ github.job }}-${{ strategy.job-index }}-
          cygwin-install-action-packages-${{ github.run_id }}-${{ github.run_attempt }}-${{ github.job }}-
          cygwin-install-action-packages-${{ github.run_id }}-${{ github.run_attempt }}-
          cygwin-install-action-packages-${{ github.run_id }}-
          cygwin-install-action-packages-

    # We only want to create a new cache when there are actual changes to the
    # packages available.  Work out what packages we have now, so we can
    # compare them later.
    - if: (inputs.cache == 'enabled' || inputs.cache == 'restoreonly') && (steps.cache-restore3.outputs.cache-matched-key != '' || steps.cache-restore320.outputs.cache-matched-key != '')
      shell: pwsh
      run: |
        Get-ChildItem -Attributes !Directory -Exclude setup.ini -Recurse -Path C:\cygwin-packages\ |
          Get-FileHash -Algorithm MD5 |
          Sort-Object -Property Path |
          ConvertTo-Csv >C:\_package-cache-hashes.csv

    - run: |
        $cacheBehaviour = '${{ inputs.cache }}'
        if ($cacheBehaviour -ne 'enabled' -and
            $cacheBehaviour -ne 'disabled' -and
            $cacheBehaviour -ne 'saveonly' -and
            $cacheBehaviour -ne 'restoreonly') {
          Write-Output "::error::Unexpected cache argument $cacheBehaviour"
          exit 1
        }
        $platform = '${{ inputs.platform }}'
        $platform = $platform -replace '^(x64|amd64)$', 'x86_64'
        $platform = $platform -replace '^i686$', 'x86'
        # validate that platform is one of the expected values
        if (($platform -ne 'x86') -and ($platform -ne 'x86_64')) {
          echo "unknown platform $platform"
          exit 1
        }
        Invoke-WebRequest https://cygwin.com/setup-$platform.exe -OutFile C:\setup.exe

        $packages = '${{ inputs.packages }}'
        $pkg_list = $packages.Split('', [System.StringSplitOptions]::RemoveEmptyEntries)
        $pkg_list = $pkg_list | % { $_.Trim() }
        $pkg_list = $pkg_list | % { $_.Trim(',') }

        # default site if not specified
        if (! '${{ inputs.site }}' ) {
          if ($platform -eq 'x86') {
            $site = 'http://mirrors.kernel.org/sourceware/cygwin-archive/20221123'
          } else {
            $site = 'http://mirrors.kernel.org/sourceware/cygwin/'
          }
        } else {
          $site = '${{ inputs.site }}'
        }

        $args = @(
         '-qgnO',
         '-s', $site,
         '-l', 'C:\cygwin-packages',
         '-R', '${{ inputs.install-dir }}'
        )

        if ($pkg_list.Count -gt 0) {
          $args += '-P'
          $args += $pkg_list -Join(',')
        }

        if ('${{ inputs.check-sig }}' -eq $false) {
          $args += '-X'
        }

        if ($platform -eq 'x86') {
          $args += '--allow-unsupported-windows'
        }

        # because setup is a Windows GUI app, make it part of a pipeline to make
        # PowerShell wait for it to exit
        & C:\setup.exe $args | Out-Default
      shell: powershell

    # Decide whether the update process above has downloaded new or updated
    # packages that aren't in the previous cache.
    - if: inputs.cache == 'enabled' || inputs.cache == 'saveonly'
      id: refresh-cache
      shell: pwsh
      run: |
        if (Test-Path -Path C:\_package-cache-hashes.csv) {
          $newHashes = Get-ChildItem -Attributes !Directory -Exclude setup.ini -Recurse -Path C:\cygwin-packages\ |
            Get-FileHash -Algorithm MD5 |
            Sort-Object -Property Path
          $diff = Compare-Object -ReferenceObject (Import-Csv -Path C:\_package-cache-hashes.csv) -DifferenceObject $newHashes -Property Hash,Path
          if ($diff.length -gt 0) {
            Write-Output update_package_cache=YesPlease >>$Env:GITHUB_OUTPUT
            Format-List -InputObject $diff
          }
        } else {
          Write-Output update_package_cache=YesPlease >>$Env:GITHUB_OUTPUT
        }

    - if: steps.refresh-cache.outputs.update_package_cache != ''
      shell: pwsh
      run: |
        if (Test-Path -Path "${{ inputs.install-dir }}\bin\tar.exe") {
          Move-Item -Path "${{ inputs.install-dir }}\bin\tar.exe" -Destination "${{ inputs.install-dir }}\bin\_tar.exe"
        }

    - if: steps.refresh-cache.outputs.update_package_cache != '' && inputs.cache-ref == 'v3'
      uses: actions/cache/save@v3
      with:
        key: cygwin-install-action-packages-${{ github.run_id }}-${{ github.run_attempt }}-${{ github.job }}-${{ strategy.job-index }}-${{ github.action }}
        path: C:\cygwin-packages
    - if: steps.refresh-cache.outputs.update_package_cache != '' && inputs.cache-ref == 'v3.2.0'
      uses: actions/cache/save@v3.2.0
      with:
        key: cygwin-install-action-packages-${{ github.run_id }}-${{ github.run_attempt }}-${{ github.job }}-${{ strategy.job-index }}-${{ github.action }}
        path: C:\cygwin-packages

    - if: steps.refresh-cache.outputs.update_package_cache != ''
      shell: pwsh
      run: |
        if (Test-Path -Path "${{ inputs.install-dir }}\bin\tar.exe") {
          Move-Item -Path "${{ inputs.install-dir }}\bin\_tar.exe" -Destination "${{ inputs.install-dir }}\bin\tar.exe"
        }

    - if: ${{ inputs.add-to-path  == 'true' }}
      run: echo "${{ inputs.install-dir }}\bin" >> $env:GITHUB_PATH
      shell: powershell

    - run: |
        # run login shell to copy skeleton profile files
        ${{ inputs.install-dir }}\bin\bash.exe --login
      shell: powershell

branding:
  color: green
  icon: terminal
